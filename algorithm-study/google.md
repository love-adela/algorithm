구글 인터뷰 준비
========
첫 인터뷰는 general coding / algorithms / data structure에 집중된 문제가 나옵니다.

구글 코리아 엔지니어링이 어떤 곳인지 아래 짧은 영상에서 확인 가능합니다.
<br>
Inside Google Engineering Korea https://youtu.be/iDM0mgrq_Ls

Mock 인터뷰 영상은 아래에서 확인하시면 됩니다. (실제 제출되는 문제보다 훨씬
난이도가 낮으니 참고해주세요.)
<br>
https://youtu.be/CJ4BTaGjNMs

준비하시면서 혹시 궁금하신 점이 있으시면 언제든지 알려주세요.

--------

질문이 많이 나오는 영역은 아래와 같습니다.

- Coding knowledge
- Algorithms
- General problem and puzzle solving
- Data structures
- Computer Science theory
- Hash tables and arrays
- Systems design

구글 인터뷰와 비슷한 유형의 문제를 아래와 같은 사이트에서 계속 연습해보시는 것을
권장드립니다.

- www.hackerrank.com
- www.leetcode.com (난이도 하-중)

아래 각각의 주제도 한번 공부해주세요.

* Big-O 표기법: Big-O는 알고리즘의 효율성을 나타내는 지표입니다. big-O를
  이용하여 내가 개선한 알고리즘이 빨라졌는지, 메모리를 많이 잡아 먹지는 않는지
  등의 알고리즘의 성능을 판단합니다. 시간에 대한 개념인 시간 복잡도와 공간에
  대한 공간 복잡도가 있습니다. Big-O 표기법과 함께 hash tables, heaps, binary
  trees, linked lists, depth-first search 그리고 recursion도 한번씩 봐주시기
  바랍니다. Algorithms에 대한 추가적인 정보는 아래를 참고해 주세요.
  <br>
  http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index

* Coding: 적어도 하나의 코딩 언어에서 뛰어난 실력을 갖추고 계셔야 합니다. (C++나
  Java를 선호) 인터뷰에서 코딩을 하실 때에는 왜 그런 결론에 도달하였는지 말로도
  잘 설명하시는 것이 중요하며 문제를 잘못 알아들으셨거나, 이해가 잘 안가시면
  interviewer에게 적극적으로 질문을 해주시기 바랍니다.

* Sorting: n*log(n) sorting algorithm을 알고 계셔야 합니다. 특히, quick sort와
  merge sort 를 다시 한번 공부해보세요. Merge sort는 quick sort 를 사용할 수
  없을 경우 유용하게 사용될 수 있으니 참고해주세요.

* Hashtables: 가장 중요한 Data structure 중의 하나이므로 어떤 기능이 있는지
  반드시 아셔야 합니다. 선호하시는 프로그래밍 언어로 array만을 이용해 구현해보실
  것을 권장 드립니다.

* Trees: 기본적인 tree construction, traversal 그리고 manipulation algorithms에
  대해서 이해하시고 계셔야 합니다. binary trees, n-ary trees, 그리고
  trie-trees에 대해서 다시 한번 살펴봐주세요. red/black tree, splay tree 혹은
  AVL tree 와 같은 balanced binary tree 타입 중에 하나는 구현이 가능하셔야
  합니다. tree traversal에 대해서도 생각해봐주세요.

* Algorithms: BFS 나 DFS 그리고 inorder, postorder, preorder의 차이점을
  공부해주세요.

* Graphs: 구글에서 Graph는 굉장히 중요합니다. 프로그래밍에서 graph를 나타내는
  기본적인 방법은 3가지가 있는데 (pointer, matrix 그리고 adjacent list) 각각의
  표현 방식과 그것의 장/단점을 공부해주세요. breadth-first search 와 depth-first
  search같은 기본적인 graph traversal algorithms의 computational complexity 와
  tradeoffs 그리고 실제 코딩에 적용시키는 방법을 이해하시는 것이 중요합니다.
  시간이 되시면 Dijkstra 나 A*와 같은 fancier algorithms도 공부해보시면
  좋습니다.

* 그 외 Data Structures: traveling salesman 나 knapsack problem과 같이
  NP-complete problems에서 가장 유명한 class를 이해하셔야 합니다. NP-complete 이
  무엇인지에 대해서도 공부해보시면 좋습니다.

* Building large-scale distributed systems
  <br>
  http://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf
  <br>
  video version
  <br>
  https://www.youtube.com/watch?v=modXC5IWTJI
  <br>
   -> 구글에서 너무 유명한 엔지니어인 Jeff Dean의 강의입니다.
